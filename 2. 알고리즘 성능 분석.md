효율적인 알고리즘 = 실행시간이 짧으면서, 컴퓨터 자원(메모리, 등)을 적게 쓰는것
- 중요도: 실행 시간(시간 복잡도, time complexity) > 메모리 공간(space complexity)

### 실행 시간 측정 방법 
1. 알고리즘을 구현하여 실행 시간 측정 
	- 동일한 (컴퓨터(하드웨어) / 컴파일러(소프트웨어)) 사용하여 알고리즘의 실행시간 비교 
		- 언어 (속도: 컴파일 방식 > 인터프리트 방식)
			![[Pasted image 20240410224852.png]]
			- 컴파일 방식 언어: C / C++ 
				- 코드 전체를 기계가 알아들을 수 있는 언어(어셈블리, etc)로 한번에 번역하고 실행
					- 번역: 프로그램 -> 목적프로그램 변환 
				- 빠름 / 기계마다 다른 기계어로 컴파일 필요(코드 이식성 낮)
			- 인터프리트 방식 언어: Python
				- 인터프리터를 사용하여 명령어 하나씩 번역 후 즉시 실행
					- 프로그램 직접 실행
				- 느린 속도, 코드 이해와 수정 쉬움 
	- clock() 함수 이용: ctime 헤더 이용
	- 성능 비교 시 사용한 데이터가 아닌 경우, 다른 결과가 나올 수 있음 
2. 알고리즘의 복잡도(Complexity Analysis) 분석 
	알고리즘 직접 구현하지 않고 대략적인 효율성 분석
	최악의 경우(실행시간 가장 오래 걸리는 경우) 자주 사용
	- **시간 복잡도 함수** $T(n)$
		- 실행 시간이 아닌, 알고리즘을 이루는 **연산의 실행 횟수**
		- 시간 복잡도 함수: **연산의 수를 n의 함수로 표현 $T(n)$**
			- 알고리즘 실행 시, 연산의 횟수는 **입력의 개수 n개**의 영향 받음
			- 연산 개수를 그래프로 그리면 n이 커질수록 연산량 차이 확인 가능 
	- **빅오(Big-O) 표기법** $O(n)$
		- 불필요한 정보를 제거하여 시간 복잡도 표시
			- $T(n)$에서 n이 커질수록 **차수가 가장 큰 항의 영향**이 커짐
				![[Pasted image 20240410235246.png]]
				![[Pasted image 20240410235159.png]]
		- 두 개의 함수 f(n), g(n)이 주어졌을 때, 모든 $n > n_0$에 대해 $|f(n)|\leq c|g(n)|$ 을 만족하는 상수 $c$와 $n_0$이 존재하면 $f(n)=O(g(n))$이다
			![[Pasted image 20240410234425.png]]
			![[Pasted image 20240410235352.png]]
		